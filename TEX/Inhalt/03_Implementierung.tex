%!TEX root = ../Masterarbeit.tex
\chapter{Implementierung}
\label{cha:implementierung}

\section{Quellen für das Erfassen von Medien-Items}
%Erforderliche und benötigte Quellen und APIs
Im folgenden Abschnitt werden in Frage kommende Quellen und APIs und deren Vor- und Nachteile in Hinsicht auf Verwendung innerhalb der Web-Applikation \arbeitstitel \ vorgestellt. Untersucht werden nicht nur APIs, sondern auch andere mögliche Formen, um an im Internet vorhandene Daten für eine Suche innerhalb von \arbeitstitel \ zu gelangen.

\subsection{Musik}
\subsubsection{MusicBrainz}
\textbf{MusicBrainz} ist eine offene Musik-Enzyklopädie, die für Mensch und Maschine lesbare Informationen über Musik öffentlich zugänglich macht \citep[Vgl.][]{musicbrainz}. Sie enthält umfangreiche Daten über Künstler und deren veröffentlichte Musik, insbesondere auch Informationen über einzelne Erscheinungen. Darüber hinaus verfügt \textbf{MusicBrainz} auf den Künstler-Profilen über umfangreiche Verweise zu weiteren Referenzen im Internet wie Wikipedia-Artikel, Youtube-Channel, Facebook-Seite, Wikidata-Eintrag \uvm \textbf{MusicBrainz} verfügt über eine offene API, die für unkommerzielle Zwecke kostenlos genutzt werden darf. Sie bietet die Entitäten \texttt{lookup}, \texttt{browse} und \texttt{search} an. Es bieten sich insbesondere die Subqueries von \texttt{artist}, \texttt{recording}, \texttt{release} und \texttt{release-group} an. Es gilt zu beachten, dass bei einem \texttt{search}-Request der gewünschte Ergebnistyp definiert werden muss. So müssen für eine Suche, bei der nicht klar ist, ob der Interpret, Titelsong oder Album eingegeben wurde, zwei Queries durchgeführt werden. Seperat bietet \textbf{MusicBrainz} den Service \textbf{Cover Art Archive} \citep[Vgl.][]{coverArtArchive} an, über den anhand von \textbf{MusicBrainz}-IDs Album Art von Releases abgefragt werden kann.


\subsubsection{RateYourMusic}
\textbf{RateYourMusic} ist wie \textbf{MusicBrainz} eine durch Nutzer gepflegte offene Datenbank, die über Musikdaten hinaus auch Daten über Filme bietet \citep[Vgl.][]{rym}. Ein für \textbf{\arbeitstitel} interessantes Feature ist die Möglichkeit sich Charts anzeigen zu lassen und diese nach diversen Kriterien, wie Genre oder Zeit, zu filtern. Leider verfügt \textbf{RateYourMusic} über keine API und verbietet auch ausdrücklich das Scrapen der Daten auf ihrer Website.

\subsubsection{OneMusicAPI}\label{subsubsec:OneMusicAPI}
\textbf{OneMusicAPI} ist eine API, die auf der Software von Bliss basiert \citep[Vgl.][]{oneMusicAPI}. Während Bliss das automatische Nachladen von Cover Art ermöglichen soll \citep[Vgl.][]{bliss}, sind mit \textbf{OneMusicAPI} Requests mit Interpret und Songtitel nach Releases möglich. Ein Nachteil der API ist, dass Informationen nur angefragt werden können, wenn Interpret und Songtitel bekannt sind. Weiterhin sind die Song-Informationen nicht so umfangreich wie die in anderen Datenbanken. Außerdem kann nur nach Informationen gefragt werden, wenn Interpret und Songtitel bekannt sind. Darüber hinaus ist die API nach 1.000 Lookups kostenpflichtig.

\subsubsection{Music Story Pro}
\textbf{Music Story Pro}s API \citep{musicStoryPro} bietet die Möglichkeit anhand von eigenen Meta-Daten zu suchen, diese zu identifizeren und mit dem richtigen Interpreten, Release oder Track zu assoziieren. \citep[Vgl.][Identification of tracks, albums and artists]{musicStoryProSolution} Ähnlich wie \textbf{OneMusicAPI} (\ref{subsubsec:OneMusicAPI}) ist die API nur begrenzt kostenlos verfügbar. Die Anzahl der Requests ist auf 50.000 pro Monat begrenzt, weiterhin ist die volle Funktionalität zahlenden Kunden vorbehalten. Dies beinhaltet \zB Review-Informationen und Bilder. Ein Vorteil bei \textbf{Music Story Pro} ist, dass eine Schnittstelle für weitere APIs angeboten wird. Dazu gehören \ua \ Spotify, Deezer, iTunes und Amazon. Außerdem implementiert es die Suche von \textbf{MusicBrainz}, indem es sowohl \gls{Release} als auch \gls{ReleaseGroup} im \textbf{MusicBrainz}-Format liefert.

\subsubsection{Discogs}
\textbf{Discogs} hat es sich zur Aufgabe gemacht die größte und umfangreichste Musikdatenbank, inkl. Market Place bereitzustellen \citep[Vgl.][]{discogs}. Außerdem stellt \textbf{Discogs} eine API bereit, die nicht nur das Durchsuchen des Datenbestandes ermöglicht, sondern auch den Market Place. Im Gegensatz zu den anderen Musikquellen, legt \textbf{Discogs} in Form einer internen Community einen größeren Wert auf den sozialen Charakter der Plattform.

\subsection{Film}
\subsubsection{IMDb}
\textbf{IMDb} ist die bekannteste Filmdatenbank im Internet. \textbf{IMDb} enthält über Filmdaten hinaus auch Informationen über alle Mitwirkenden, Bewertungen, Plots \uvm Eine offizielle API bietet \textbf{IMDb} derzeit nicht, jedoch werden auf der Seite die Daten in Textform zum Download bereitgestellt, welche für unkommerzielle Zwecke genutzt werden dürfen.

\subsubsection{themoviedb.org}
\textbf{The Movie Database} ist eine offene Film- und TV-Datenbank, die ursprünglich aus Daten der \textbf{Open Media Database} \citep{omdb} entstanden ist und darüber hinaus auf nutzergenerierten Inhalten basiert \citep[Vgl.][]{tmbd}. Außerdem bietet \textbf{The Movie Database} eine unkommerziell verwendbare API für Entwickler, die sehr gut mit \textbf{apiary}\footnote{\textbf{apiary} ist ein Framework zur Beschreibung und Dokumentation von APIs. Es ist insbesondere dafür vorgesehen vor dem Prozess der eigentlichen Implementierung, die Funktionalität im Voraus zu definieren. \citep{apiary}} dokumentiert ist.

\subsubsection{Rotten Tomatoes}
\textbf{Rotten Tomatoes} \citep{rottenTomatoes} ist eine Sammlung von Filmkritiken und bietet in diesem Zuge auch detaillierte Informationen über Film- und TV-Produktionen \citep[Vgl.][]{rottenWiki}. Standardmäßig ist die Anzahl von Requests pro Sekunde und Tag limitiert. Zu beachten ist außerdem, dass die API lediglich für die Nutzung in den Vereinigten Staaten vorgesehen ist. \citep[Vgl.][Important Notes about API Usage]{rottenAPI} Zwar verwendet \textbf{Rotten Tomatoes} eine eigene Datenform, in der die Filme abgebildet sind, jedoch ist in einem Großteil der Datensätze im Feld \texttt{alternate\_ids} auch die \textbf{IMDb}-Id aufgeführt. Somit bietet die API auch die Möglichkeit, den Datensatz eines Filmes anhand der \textbf{IMDb}-Id zu liefern.

\subsection{Sonstige}
\subsubsection{Wolfram|Alpha}
\textbf{Wolfram|Alpha} \citep{wolframAbout} bietet eine begrenzt kostenlose API. So ist eine kostenlose Verwendung für unkommerzielle Testzwecke auf 2000 API-Calls pro Monat begrenzt \citep[Vgl. How much I may use the Wolfram|Alpha API?][]{wolframAPIAbout}. Insbesondere das Thema \glqq People \& History\glqq \ \citep{wolframTopicHistory} ist für \arbeitstitel \ von Interesse, da das Auflösen von historischen Ereignissen, sowie Daten über Personen eines hohen Bekanntheitsgrades, zu einem Zeitraum damit ermöglicht werden kann. Speziell Geburtsdaten, Todesdatum und Amtsperioden lassen sich über das Auslesen der sogenannten \texttt{Pods} \citep[Vgl. Basics of Wolfram|Alpha Output][]{wolframAPIDocumentation} erfassen.

\subsubsection{Wikipedia}
\textbf{Wikipedia} ist ein Online-Nachschlagewerk und bietet laut eigener Angabe \glqq rund 30 Millionen Artikel [...] in über 280 Sprachen\grqq \ \citep[Vgl.][]{wikiWiki}. Im Gegensatz zu \textbf{Google} und \textbf{Wolfram|Alpha} verfolgt die \textbf{Wikipedia} die Idee einer kollaborativen Enzyklopädie, was sich auch in der Lizensierung niederschlägt, da sie unter der Creative-Commons-Attribution-ShareAlike-Lizenz weiter verwendet werden darf. Ein Nachteil ist wiederum, dass es einen großen Aufwand bedeutet, die Daten über Techniken wie das Web-Scraping\footnote{Web-Scraping ist eine Technik zum automatischen Auslesen von Quelltext, auf die in \ref{subsec:webScraping} genauer eingegangen wird.} auszulesen.

\subsubsection{Marvel API}
Eine weitere API, die sich \va aufgrund des Inhaltes für die Verwendung in \arbeitstitel \ anbieten würde, ist die \textbf{Marvel API} \citep{marvel}. Über diese lassen sich insbesondere inhaltliche Informationen über Marvel-Comics ermitteln. Leider gibt es darüber hinaus keine Informationen über Erscheinungsdaten \oae verwertbare Daten, die sich zeitlich einordnen lassen. Das schließt derzeit auch eine Verwendung dieser API über den Umweg aus, populäre Comics anderweitig zu suchen und spezifische Daten von dieser API nachzuladen.

\section{Quellen für das Einbinden von Media-Inhalten im Player}
Im Folgenden werden die Dienste vorgestellt, die verwendet werden können, um Audio- und Video-Content in der Playlist von \arbeitstitel, wenn auch lediglich repräsentativ oder als Verlinkung, darzustellen.

\subsection{Video}
\paragraph{Trailer}
Filme in \arbeitstitel \ einzubinden oder gar anzuzeigen, ist allein urheberrechtlich nicht erlaubt. Repräsentativ können jedoch Trailer, soweit diese online frei vorhanden sind, verwendet werden. Trailer werden oft von den Film-Produktionsfirmen selbst online zur Verfügung gestellt, um eine schnellere Verbreitung im Internet zu erzielen und den Film einer breiteren Masse bekannt zu machen. Für diesen Zweck bietet \textbf{TrailerAddict} \citep{trailerAddict} eine API, die das embedden von Trailern vereinfacht. Für die Darstellung von Trailern über \textbf{TrailerAddict} ist jedoch Flash 9 erforderlich \citep[Vgl.][]{trailerAddictAbout}, was \uU große Restriktionen nach sich zieht, sollte der User kein Flash installiert haben.

\paragraph{YouTube}
Zum Einbetten von Musikvideos, Filmen und Film-Trailern bietet sich im Playlist-Bereich das Einbinden von \textbf{YouTube}-Videos \citep{youtube} an. Die \textbf{YouTube}-API kann über die Verwendung der Upload-Dienste hinaus auch für das Suchen von Videos oder Playlists verwendet werden \citep[Vgl.][]{youtubeAPI}.

Ein Problem, welches gegen die Verwendung von \textbf{YouTube}-Inhalten spricht, sind die vermehrt blockierten Inhalte aufgrund von Urheberrechtsansprüchen, was insbesondere in Deutschland eine Vielzahl nicht abspielbarer Videos bedeutet.

% You can use the API to fetch search results and to retrieve, insert, update, and delete resources like videos or playlists.


\paragraph{Vimeo}
\textbf{Vimeo} \citep{vimeo} ist ebenso wie \textbf{YouTube} ein Video-Dienst der das Uploaden von Videos mit der sozialen Komponente verbindet. \textbf{Vimeo} bietet momentan drei verschiedene APIs an. Die derzeit offizielle API gibt es in zwei Versionen, die \textbf{Simple API} \citep[][Vimeo Simple API]{vimeoAPIsSimple} und die \textbf{Advanced API}  \citep[][Vimeo Advanced API]{vimeoAPIsAdvanced}. Momentan arbeitet \textbf{Vimeo} an einer neuen API, die bereits verwendet werden kann, sich aber noch im Beta-Stadium befindet \citep[][Vimeo API (Beta)]{vimeoAPI}. 

Eine Besonderheit ist, dass \textbf{Vimeo} darüber hinaus noch eine als \textbf{JavaScript API} \citep[][Vimeo JavaScript API]{vimeoJSAPI} deklarierte API bereitstellt, die insbesondere die Steuerung des \textbf{Vimeo}-Players ermöglicht. Diese Funktionalität kann für die Realisierung des Players genutzt werden. 

Der große Nachteil von \textbf{Vimeo} \bzgl der Nutzung für \arbeitstitel \ ist allerdings, dass \textbf{Vimeos} Kernaufgabe ist, eine Plattform für Videos, die \va künstlerischer Natur sind, zu bieten. D.h., es gibt zwar Musikvideos und Film-Trailer, jedoch nicht in der Menge und Qualität, wie es bei YouTube der Fall ist.

\subsection{Audio}
\paragraph{Spotify}
Über den kommerziellen Streaming-Dienst \textbf{Spotify} \citep{spotify} lässt sich über ein musikalisches Repertoire bekannter Plattenlabels auf einer Vielzahl von Desktop- und Mobil-Geräten zugreifen. \textbf{Spotify} stellt eine API bereit, über die sich die verfügbaren Musiktitel durchsuchen und einbetten lassen können. Aufgrund des Freemium-Konzepts ergibt sich der Nachteil, dass ein Nutzer von \arbeitstitel \ über einen \textbf{Spotify}-Account verfügen muss, möchte er unbegrenzt über die Web-Applikation Musik hören. Spotify bietet unterschiedliche Möglichkeiten, auf sowohl Meta-Informationen von Musikveröffentlichungen und Künstlern (\textit{Metadata API}), als auch die Musik selbst zuzugreifen. Während die \textit{Apps API} and \textit{Views API} dafür vorgesehen sind, Applikationen für die Stand-Alone-Version von \textbf{Spotify} zu entwickeln, bedienen \textit{Libspotify SDK} und \textit{CocoaLibSpotify} den Zweck, Musik von Spotify in eigens entwickelten Applikationen zu streamen. \citep[Vgl.][]{spotifyDeveloper} Desweiteren wird sowohl über die Web-, als auch über die Stand-Alone-Applikation die Möglichkeit angeboten, Einbettungscode von einzelnen Songs, eines Albums oder Playlisten zu generieren. Das automatische Generieren des Embed-Codes wird derzeit über keine der Schnittstellen angeboten. Jedoch weist der einzubindende Code für den IFrame immer die gleiche Struktur auf. Daher bietet es sich an, lediglich die \textit{Metadata API} einzubinden, um die \textbf{Spotify}-Id eines Songs zu erhalten, und den IFrame nach der vorgegebenen Struktur, die im Listing \ref{lst:spotifyIFrame} zu sehen ist, innerhalb von \arbeitstitel \ zusammenzubauen.

\medskip
\lstinputlisting[language=HTML,caption={Spotify IFrame-Code},label={lst:spotifyIFrame}]{Inhalt/Code/spotifyIFrame.html}

\section{Techniken}
Zum Erfassen unterschiedlichster Daten im Internet gibt es verschiedene Möglichkeiten, wobei diese stark vom Angebot des Web und der einzelnen Anbieter abhängig sind. Im Folgenden werden mögliche Techniken, Daten unterschiedlicher Quellen zu erfassen, kurz vorgestellt und deren Vor- und Nachteile für die Entwicklung von \arbeitstitel \ herausgestellt. Auf dessen Grundlage wird entschieden, welche Datenquellen zu bevorzugen sind.

\subsection{Web-Services}
Web-Services folgen nicht zwangsweise den gleichen Gestaltungsgrundsätzen und basieren nicht auf den gleichen Kern-Formaten oder Protokollen, obwohl sie sich im Web bereits durchgesetzt und sich als erfolgreich erwiesen haben \citep[Vgl. Seite 67][]{Fensel2011}. Im Folgenden werden die Standards kurz hinsichtlich ihres Zweckes für \arbeitstitel \ vorgestellt, sollten diese bei der Implementierung eine Rolle spielen.

\paragraph{SOAP}
\textbf{SOAP} ist ein Netzwerkprotokoll, das dem Datenaustausch zwischen Systemen dient und Remote Procedure Calls ermöglicht. Daten werden im XML-Standard repräsentiert und über Internet-Protokolle wie z.B. HTTP und FTP übertragen. SOAP ist ein Wege, um mit einem Webservice zu kommunizieren. Anfragen des Clients und Antworten des Servers werden über das SOAP-Protokoll übertragen. \citep[Vgl.][]{wikiSoap}

Der sogenannte SOAP-Envelope (dt. Umschlag) gibt vor, in welcher Form Daten oder Funktionsaufrufe gesendet werden müssen, damit sie vom Webservice ausgeführt werden können. Der Header des SOAP-Envelope ist hierbei optional, während der Body vorhanden sein muss, da er alle nötigen Informationen, wie zum Beispiel die aufzurufende Funktion und deren Parameter enthält oder den angeforderten Datensatz.

Obwohl die Abkürzung SOAP ursprünglich als Acronym für Simple Object Access Protocol galt, wird sie seit Version 1.2 offiziell nicht mehr als Akronym verwendet. Zumal es nicht nur dem Zugriff auf Objekte (Object Access) dient, sondern auch keinesfalls einfach (Simple) ist. \citep[Vgl.][]{wikiSoap}

\paragraph{REST}
Ein Großteil der im Internet verfügbaren APIs basiert auf dem \textbf{RESTful}-Standard für Web-Anwendungen. \textbf{REST} \glqq bezeichnet ein Programmierparadigma für Webanwendungen.\grqq \citep[][]{wikiRest} Der URI-Standard legt fest, das jeder Resource eine URI zugewiesen ist. Das bedeutet, dass jeder Funktionsaufruf eine eigene URI besitzt, die aufgerufen werden muss, um eine Aktion auszuführen. Daher muss ein HTTP- Request alle notwendigen Daten enthalten, die der Server benötigt, um die Anfrage zu verstehen. Damit ist jeder Funktionsaufruf ein in sich geschlossener Aufruf des Clients und es bedarf keiner Zustandsinformationen, die auf dem Server gespeichert werden müssen, sodass auch von der Zustandslosigkeit bei REST gesprochen. Diese Art von Funktionsaufruf hält die zu sendende Datenmenge sehr gering und benötigt zudem keine weitere Transportschicht, über die Requests und Responses übertragen werden müssen. Anstatt dessen arbeitet ein Client mit Repräsentationen einer Resource.

\subsection{Library- und API-Wrapper}
Unabhängig von der Art der Implementierung der Web-Services existieren für einen Großteil von \va bekannten APIs sogenannte \textbf{Wrapper}. Ein API-Wrapper kann dabei unterschiedliche Bedürfnisse bedienen. Zum einen können lediglich einzelne, von der API bereitgestellte, Funktionen implementiert sein, um unabhängig von Formaten oder Programmiersprachen auf die Funktionalität einer API zugreifen zu können. Dies kann sowohl die Verwendung, als auch die Einbindung einer API sehr stark vereinfachen. \citep[Vgl.][]{wikiWrapper}

Zum anderen kann ein Wrapper auch die Funktionalität der API erweitern, indem \zB intern mehrere API-Calls sinnvoll miteinander verknüpft werden und damit einfacher weiter verarbeitet werden können. \citep[Vgl.][]{wikiWrapper}

\subsection{Web-Scraping}
\label{subsec:webScraping}
Das Web-Scraping (oder Screen-Scraping) ist eine Technik, mit der Informationen einer Webseite gesammelt werden können. Die für \arbeitstitel \ in Frage kommende Art des Web-Scraping ist das Herunterladen eines externen Quelltextes via HTTP, der über Informationen, insbesondere über Film- oder Musikcharts verfügt. Aus der vorangegangenen Analyse der Suchdienste (siehe Kapitel \ref{cha:analyse}) geht bereits hervor, dass es im Internet eine große Menge an für \arbeitstitel \ interessanten Daten gibt, im Gegensatz dazu jedoch keine passenden Schnittstellen existieren.

Ein Nachteil ist, dass für das Sammeln von Daten meist ein größerer Aufwand nötig ist, als lediglich eine offizielle API anzusprechen oder einen Wrapper einzubinden.

Zwar kann durch das Web-Scraping auf nahezu alle frei zugänglichen Daten des Webs zugegriffen werden, für die es keine Schnittstellen gibt, jedoch wird diese Methode von vielen Websites ausdrücklich verboten. Während die meisten Barrieren auf unterschiedlichste Arten umgangen werden können, können dadurch Urheberrechte verletzt werden, die strafrechtliche Konsequenzen nach sich ziehen können.

\subsection{Download/Dumps}
Auf Wikipedia existieren brauchbare Seiten, die jeweils die Musik- und Film-Charts für jedes verfügbare Jahr enthalten. Die Vorgehensweise, benötigte Daten zunächst herunterzuladen und weiter zu verarbeiten, ist jedoch manuell aufwändig. Informationen müssen erst händisch herausgesucht werden und nach den Vorgaben von Wikipedia über die Webseite bereitgestellte Funktion in Text-Dateien exportiert werden. Inhalte können über die URL \url{http://en.wikipedia.org/w/index.php?title=Special:Export} heruntergeladen werden. Diese Textdateien müssen geparst werden, wobei das Parsen der Daten in der von Wikipedia genutzten Skriptsprache Lua relativ unkomfortabel ist. Um das Editieren von Wikipedia-Artikeln einer breiten Masse möglich zu machen, ist Lua mit seiner einfachen Syntax von großem Vorteil. Dafür ist der Text nahezu zusammenhangslos und semantisch nicht automatisch auswertbar. Außerdem erfordert dies eine lokale Datenhaltung der erfassten Daten, die zusätzlich regelmäßig gewartet werden muss, wenn es neue Daten gibt, oder Daten geändert werden. In Listing \ref{lst:wikiExcerpt} ist ein Auszug eines Wikipedia-Downloads zu sehen.

\medskip
\input{Inhalt/Code/wikipedia}


\subsection{Sweble Wikitext Component}
Das \textbf{Sweble Wikitext Components module} soll das Parsen von MediaWikis Wikitext ermöglichen und darüber hinaus eine Engine bieten, die versucht das Verhalten eines MediaWiki zu emulieren. \citep[Vgl.][]{sweble} \textbf{Sweble} ist Open Source verfügbar und addressiert die im folgenden Zitat beschriebene Problematik: 
\begin{quotation}\glqq Content von Wikis wird durch spezialisierte Sprachen beschrieben, die allgemein als Wiki Markup Languages bezeichnet werden. Trotz ihres unschuldigen Namens, können diese Sprachen ziemlich komplex sein und über ein ebenso komplexes visuelles Layout, als auch über [vollständige; St.]  Programmiersprachen-Features verfügen, wie \zB Variablen, Schleifen, Funktionsaufrufe und Rekursion. \grqq \footnote{\citet[Vgl.][Introduction]{DohrnSweble} [eigene Übersetzung]. Originalwortlaut: \glqq The content of wikis is being described using specialized languages, commonly called wiki markup languages. Despite their innocent name, these languages can be fairly complex and include complex visual layout mechanisms as well as full-edged programming language features like variables, loops, function calls, and recursion.\grqq}\end{quotation}

Dies verdeutlicht die Problematik, dass Wikipedia zwar über diverse für \arbeitstitel \ interessante Artikel verfügt, es jedoch schwer ist, diese Daten automatisch zu erfassen. Da eine aussagekräftige Analyse des tatsächlichen Nutzens der \textbf{Sweble}-Software für \arbeitstitel \ als sehr zeitaufwändig eingeschätzt wird, ist davon abgesehen worden, die Software genauer zu untersuchen.\todo{kann man den satz so lassen oder klingt das zu mimimi und passt nicht hierher?}


\subsection{Mergen von Daten / Multiple Requests für einen Datensatz}
Die Verwendung von existierenden und frei verfügbaren APIs ist klar zu bevorzugen, da diese mit hoher Wahrscheinlichkeit konsistente Daten in einem großen Umfang liefern. Da die Form der Daten nicht zwangsweise auf die Ansprüche von \arbeitstitel \ zugeschnitten sind, kann es notwendig sein, für einzelne Daten eines Datensatzes verschiedene Services zu verwenden. So werden \zB für die Anzeige eines Songtitels in der Web-Applikation sowohl als Suchvorschlag als auch als Suchergebnis-Item zunächst alle benötigten Informationen von der \textbf{MusicBrainz}-API bezogen und die angezeigten Cover von der \textbf{CoverArt}-API einzeln nachgeladen.

\subsection{Begrenzung von Requests pro Sekunde in den unterschiedlichen APIs}
MusicBrainz limitiert, wie einige andere APIs auch, die Anzahl von Anfragen einer Ressource anhand von Kriterien des User-Agents und der IP-Addresse. Darüber behält sich \textbf{MusicBrainz} vor, bei einer generellen Überlastung des Servers eingehende Anfragen zu blockieren. Dieses Limit kann schnell überschritten werden, wenn einzelne Requests erfolgen, wie \bspw beim Nachladen einzelner Informationen pro Item. Aus diesem Grund muss dem Sammeln größerer Mengen an Items entweder mehr Zeit gegeben, oder generell die Anzahl an Items begrenzt werden. Der beste Kompromiss ist hier, immer ein Set von Medien-Items anzufragen, welches die Kapazität nicht überschreitet, und anschließend Sets jeweils einzeln nachzuladen.

\section{Architektur der Web-Applikation}
Die Web-Applikation wird serverseitig mittels Javascript umgesetzt. Die Software-Plattform Node.js \citep{nodejs} bietet ein einfaches Konzept zur Erstellung und Inbetriebnahme von skalierbaren Netzwerk-Applikationen. Im Bezug auf \arbeitstitel \ ist das Konzept der Ereignisgesteuerten Architektur\footnote{Die Ereignisgesteuerte Architektur (engl. Event-Driven Concept) verfolgt den Ansatz, Funktionalität basierend auf Ereignissen auszuführen. Insbesondere ist für die Entwicklung von \arbeitstitel \ der Aspekt der parallelen Bearbeitung von Requests zu nennen.} von großem Vorteil, da die Kommunikation mit mehreren APIs um einiges beschleunigt werden kann, indem die API-Requests von der Asynchronität Gebrauch machen.

Ein weiterer maßgeblicher Vorteil ist, dass für nahezu jede in dieser Arbeit untersuchte Schnittstelle auch ein Wrapper existiert, was die Einbindung der unterschiedlichen Quellen stark vereinfacht.

Im Folgenden wird das Setup der Web-Applikation, sowie integrierte Module und deren Verwendung anhand von Code-Beispielen erläutert.

\subsection{Express.js}
Das Web-Application-Framework \textbf{Express.js} \citep{expressjs} wird verwendet, da es eine Palette von Funktionen zur einfachen Implementierung von Web-Applikationen mit \textbf{Node.js} bietet und trotzdem flexibel und leichtgewichtig ist. Es ist als Schicht zwischen Funktionalität und Frontend zu verstehen und agiert als API \citep[Vgl.][]{expressjs}. Das ist speziell für \arbeitstitel \ von Vorteil, da dies das Bereitstellen einer API für die Funktionalität von \arbeitstitel \ bietet und damit das Entwickeln von weiteren Anwendungen vereinfacht wird.

\subsubsection{Code-Generierung mit Yeoman}
Das Gerüst der Web-Applikation ist mittels \textbf{Yeoman} \citep{yeoman}, einem Scaffolding-Tool\footnote{Scaffolding bedeutet in diesem Kontext die automatische Generierung eines Web-Applikations-Gerüsts.} für Webapps, generiert worden. Der Workflow von Yeoman basiert auf den drei Tools \textbf{Yo}, \textbf{Grunt} \citep{grunt} und \textbf{Bower} \citep{bower}. Bower ist ein Package Manager für das Frontend, Grunt ein Task Runner, mit Hilfe dessen Automatisierungsprozesse und Build-Skripte ausgeführt werden können. Yo kann mittels verschiedener Generatoren und Konfigurationen den Boilerplate-Code\footnote{Boilerplate-Code bezeichnet Teile von Code, die an vielen Stellen mit gar keiner oder nahezu keiner Veränderung benötigt werden. \citep[Vgl.][]{wikiBoilerplate}} einer Web-Applikation und ein passendes Grunt Skript generieren.

\arbeitstitel \ ist mithilfe des Yeoman-Generators \textbf{generator-express} \citep{yeoExpress} generiert worden. Die generierte Projektstruktur implementiert bereits das MVC-Framework, in dem Funktionalität, Darstellung und Objekte klar voneinander getrennt werden. Außerdem ist MongoDB als Default-Datenbank vorkonfiguriert.

\subsection{Umsetzung und verwendete Tools im Frontend}
Im Folgenden werden verwendete Libraries und deren Nutzen, sowie sonstige Besonderheiten der Implementierung des Frontends erläutert.

\paragraph{Jade und Stylus}
Im Frontend werden die Werkzeuge Jade und Stylus verwendet. Jade \citep{jade} ist eine Node Template Engine und vereinfacht das Schreiben von HTML-Code, indem es eine eigene Syntax implementiert. Über die vereinfachte Schreibweise hinaus implementiert sie auch Iterationen, Bedingungen und Filter. Außerdem kann mithilfe sogenannter Mixins Funktionalität, die im Frontend benötigt wird, implementiert und somit an weiteren Stellen wiederverwendet werden.

Stylus \citep{stylus} ist eine für Node entwickelte Sprache, deren Kompilat CSS ist. Die Syntax ist im Gegensatz zu CSS stark vereinfacht, was sich \ua im Weglassen von Zeichen wie \zB Klammern niederschlägt. Weiterhin bietet sie Funktionen, wie die Deklaration von Variablen, Funktionen und Mixins.

\paragraph{Select2}
\textbf{Select2} \citep{select2} ist eine konfigurierbare Implementierung einer Selectbox. Sie bietet neben dem einfachen Suchen und einer Autosuggest-Funktion bereits Features wie das automatische Nachladen von Remote Datasets und unterstützt infinites Scrollen \citep[Vgl.][]{select2}. Da Select2 auf jQuery basiert, sind keine weiteren Includes erforderlich. Außerdem ist es über \textbf{Bower} erhältlich.

\paragraph{Font Awesome}
Die Library \textbf{Font Awesome} \citep{fontAwesome} bietet ein Set von derzeit 369 Icons an. Sie lässt sich mittels \textbf{Bower} installieren und kann nach dem Einbinden der CSS-Files durch die Angabe der vorgegebenen CSS-Klassen verwendet werden. Dies bietet den Vorteil, dass die angezeigten Icons sowohl stilkonform, als auch von der dargestellten Größe veränderbar sind.

\paragraph{Darstellung von Filmplakaten in unterschiedlichen Formaten}
Um das User Interface trotz verschiedener Medientypen und deren Repräsentierung möglichst aufgeräumt und übersichtlich zu halten, wird die Darstellung der Medien-Items in Rasterform umgesetzt. Somit ist für jedes Item eine quadratische Anzeige vorgegeben. Dies funktioniert für Album-Cover größtenteils ohne Darstellungsprobleme, da diese fast ausnahmslos ebenfalls im quadratischen Format vorliegen. Hier können allerdings unschöne Darstellungsfehler auftreten, da die Album-Cover in unterschiedlichen Größen verfügbar sind. Diese lassen sich mit Angabe einer festen Höhe und Breite durch CSS verhindern. 

Eine besondere Behandlung wird für die Darstellung von Filmplakaten benötigt. Diese liegen zwar größtenteils im Hochformat vor, jedoch gibt es auch hier Ausnahmen. Das Problem kann \zB damit gelöst werden, dass ein Teil des Plakats in originaler Auflösung dargestellt wird. Jedoch sind die dargestellten Bildausschnitte der Filmplakate dadurch nicht zuverlässig aussagekräftig. In der Web-Applikation wird das Plakat unabhängig von der Größe, der Auflösung und des Formats immer auf eine Breite und eine Höhe von jeweils 200px gestreckt, \bzw gestaucht.










\subsection{Umsetzung und verwendete Tools im Server}
Die Funktionalität des Servers baut auf verschiedenen Tools und Frameworks auf, dessen Zusammenspiel im Folgenden kurz vorgestellt wird. Dabei ergibt sich die Struktur und der Ablauf der Requests größtenteils daraus, wie die unterschiedlichen Datenformen von den verwendeten APIs erfasst werden können. Daher wird im Folgenden zunächst auf die grobe Struktur und die interne Architektur von \arbeitstitel \ eingegangen, um darauffolgend anhand von Code-Beispielen der verwendeten Tools, deren Nutzen und desweiteren die genaue Funktionalität erläutern zu können.



\subsubsection{Interner Aufbau und Ablauf von Requests}
In Abbildung \ref{fig:requestDiagram} ist der grobe Ablauf von Nutzer-Eingabe bis zur Lieferung der resultierenden Medien-Items zu sehen. Bei der Eingabe eines Suchbegriffes werden zunächst mögliche Suchvorschläge gegeben.\footnote{Der schematische Ablauf der Sammlung der Suchvorschläge ist in Abbildung \ref{fig:suggestionsRequestDiagram} zu sehen und wird in Abschnitt \ref{subsec:suggestions} beschrieben} Anhand der Suchvorschläge kann der Nutzer sich ein Item aussuchen, dessen Zeitraum durchsucht werden soll. Anhand diesen Zeitraumes sendet \arbeitstitel \ Sucherequests an die verbundenen APIs und Quellen und gibt ein Set an Suchergebnissen (\texttt{MusicResults}) und abspielbaren Medieninhalten (\texttt{TrailerResults}) zurück.\footnote{Der schematische Ablauf der Sammlung von Suchergebnissen ist in Abbildung \ref{fig:searchResultsRequestDiagram} zu sehen und wird in Abschnitt \ref{subsec:results} genauer beschrieben.}

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=1\textwidth]{Retrieving.pdf}
		\caption{Request-Diagramm}
	\end{center}
	\label{fig:requestDiagram}
\end{figure}

\subsubsection{Erfassen von Suchvorschlägen anhand eines Suchbegriffes}
\label{subsec:suggestions}
In Abbildung \ref{fig:suggestionsRequestDiagram} wird der interne Ablauf zur Erfassung der Suchvorschläge schematisch dargestellt. Bei Eingabe eines Suchbegriffs, wird bei den unterschiedlichen APIs und Quellen nach passenden Suchvorschlägen gesucht. Um Suchvorschläge im Bereich Film zu finden, werden passende Items von \textbf{Rotten Tomatoes} und \textbf{IMDb} gesammelt. 

Gleichzeitig findet die Suche nach Suchvorschlägen im Bereich Musik statt. Aufgrund der Architektur der \textbf{MusicBrainz}-API, in der der erwartete Rückgabetyp eines Requests im Request selbst definiert sein muss, wird parallel nach passenden Songtiteln und Interpreten, welche den Suchbegriff enthalten, gesucht. Die Besonderheit beim Erfassen der Musik-Suchvorschläge ist, dass für jedes Item ein zusätzlicher Request an die Cover-Art-API nötig ist, um ein repräsentatives Thumbnail in der Selectbox anzeigen zu können. Weitere potenzielle Medientypen sind mit der grauen Box repräsentiert. Sobald alle benötigten Daten für die Anzeigen gesammelt wurden, indem sie auf interne SuggestionItem-Objekte gemappt wurden, werden diese zurück an das Frontend geschickt und dem Nutzer angezeigt.

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=0.7\textwidth]{RetrievingSuggestions.pdf}
		\caption{Suggestions - Request-Diagramm}
	\end{center}
	\label{fig:suggestionsRequestDiagram}
\end{figure}


\subsubsection{Erfassen von Suchergebnissen anhand eines Zeitraumes}
\label{subsec:results}
In Abbildung \ref{fig:searchResultsRequestDiagram} ist der interne Ablauf der Erfassung von Suchergebnissen schematisch dargestellt. Ausgangspunkt der Grafik ist ein bereits ausgewählter Zeitraum (\texttt{SuggestionDate}). Anhand des Datums wird mittels Scrapen der passenden \textbf{IMDb}-Seite eine Liste von IMDb-IDs erfasst. Alle restlichen Daten können mit Angabe der IMDb-ID von den APIs \textbf{RottenTomatoes} und \textbf{TrailerAddict} nachgeladen werden. Die Ergebnisse resultieren im Falle der Abfrage bei \textbf{RottenTomatoes} in einem Set von Movie-Results, im Falle der Abfrage von \textbf{TrailerAddict} in einer Liste von Trailern.\footnote{Genauer besteht die Liste von Trailern aus einer Liste von Quellcode-Snippets, die die eingebetteten Trailer-Videos enthalten.}

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=1\textwidth]{RetrievingSearchresultsAndPlaylist.pdf}
		\caption{Searchresults - Request-Diagramm}
	\end{center}
	\label{fig:searchResultsRequestDiagram}
\end{figure}


\subsubsection{Interne Datenübertragung mittels MongoDB}
Da die in \arbeitstitel \ angezeigten und verarbeiteten Daten dynamisch von unterschiedlichen Quellen geladen werden sollen, ist eine Datenhaltung im Prinzip nicht erforderlich. Jedoch werden die zur Laufzeit erfassten Daten zwischengespeichert und intern auf Objekte gemappt.

Zu diesem Zweck wird die dokumentenorientierte Datenbank \textbf{MongoDB} \citep{mongodb} verwendet. Im Gegensatz zu relationalen Datenbanken lässt sich mit der NoSQL-Strategie eine flexible Datenstruktur erstellen. Das macht im Falle von \arbeitstitel \ besonders Sinn, da sich Art und Umfang der Daten, die verarbeitet werden, sehr schnell ändern können. Außerdem vereinfacht dies auch die Erweiterbarkeit der Web-Applikation.

\paragraph{mongoose}
\textbf{mongoose} ist ein Objekt-Modellierungs-Tool für die Verwendung von MongoDB \citep{mongodb} unter Node.js. \citep[Vgl.][]{mongoose} Unter anderem bietet \textbf{mongoose} eine unkomplizierte, Schema-basierte Lösung zur Modellierung von Anwendungsdaten und verfügt über Business-Logik, Funktionen wie das Typisieren, Validieren und vereinfacht das Formulieren von Datenbank-Queries \uvm \citep[Vgl.][]{mongoose}

\medskip
\begin{lstlisting}[language=JavaScript,caption=Deklaration des ResultItem mit Mongoose,label={lst:mongoose}]
var resultItemSchema = new Schema({
	mediaType: {type: String, enum: ['audio', 'video', 'text', 'other']},
	mediaSubtype: {type: String, enum: ['movie', 'music', 'time', 'other']},
	date: Date,
	title: String,
	img_url: String,
	id: String,
	source: String,
	url: String,
	release_mbid: String
});
\end{lstlisting}


\paragraph{SuggestionItem}
Bei Eingabe eines Suchbegriffes werden zunächst die aktivierten APIs durchsucht. Dabei werden gleichzeitig multiple Suchanfragen an externe Datenquellen geschickt, wobei für jede API oder Datenquelle unterschiedliche Besonderheiten zu beachten sind. Um zu gewährleisten, dass eine Suchanfrage sowohl über die Eingabe eines Titels, als auch über die Eingabe des Interprets zum passenden Ergebnis führt, werden zwei Suchanfragen gleichzeitig an die \textbf{MusicBrainz}-API geschickt. Dies liegt daran, dass die \textbf{MusicBrainz}-API die Angabe der Entität vorraussetzt, nach der gesucht werden soll. Das heißt, dass eine Eingabe von \bspw \glqq Prince\grqq \ sowohl zu Songs des Interpreten \glqq Prince\grqq , als auch zu Songs, in denen das Wort \glqq Prince \grqq \ vorkommt.
\ref{fig:suggestionItem}

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=1\textwidth]{Klassendiagramm.pdf}
		\caption{Objekt-Diagramm des Suggestion-Objektes}
	\end{center}
	\label{fig:suggestionItem}
\end{figure}


\subsubsection{Erfassen von Medien-Items von externen Quellen}
Das Erfassen von Daten wird durch das Zusammenspiel mehrerer Module bewerkstelligt. Dies sind über die API-Wrapper hinaus die Module \textbf{async}, \textbf{node-rest-client}, \textbf{cheerio} und \textbf{request}.
Im Folgenden werden der Funktionsumfang und die Restriktionen der verwendeten API-Wrapper erläutert. Daraufhin wird erklärt, inwiefern die zusätzlichen Module zur Komplettierung der Implementierung nötig sind.

\paragraph{NodeBrainz}
Das Node-Modul \textbf{NodeBrainz} ist ein schlanker Wrapper, der vollen Zugang zur MusicBrainz API (Version 2) bietet. \citep[Vgl.][]{nodebrainz} Dadurch wird eine komfortable Verwendung der \texttt{search}-Entität ermöglicht. Die Suche von Interpreten und Songtiteln wird mithilfe des \textbf{NodeBrainz}-Moduls bewerkstelligt.

\paragraph{Cover Art for Node}
Die CoverArt-API ist eine separate API von \textbf{MusicBrainz}, die das Nachschlagen von CoverArt anhand einer MusicBrainz-\texttt{release}-ID ermöglicht. Das Node-Modul \textbf{Cover Art for Node} implementiert diese Funktionalität und bietet zum einem die Möglichkeit Cover-Art in binärer Form zurück zu liefern, zum anderen ist es möglich die gelieferten Bild-URLs zu Cover-Art in unterschiedlichen Größen zu erfassen. \citep{coverart}


\paragraph{node-imdb-api}
Da \textbf{IMDb} über keine offizelle API verfügt, nutzt \citeauthor{nodeImdbApi} mehrere inoffizelle APIs, die Teile ihrer Daten aus den nächtlich erscheinenden Daten der \textbf{IMDb} aggregieren. Da keine dieser APIs vollständig ist, vereint \textbf{node-imdb-api} mehrere dieser RESTful APIs der inoffizellen Seiten. \citep[Vgl.][]{nodeImdbApi}

\paragraph{node-rest-client}
Für Requests an die Schnittstelle \textbf{TrailerAddict} wird das Node-Modul \textbf{node-rest-client} verwendet. \citep{nodeRestClient} Es vereinfacht Requests an REST-APIs und liefert JavaScript-Objekte zurück, dessen Verarbeitung dann selbst übernommen werden muss. Es erfordert zwar mehr Aufwand, einen Request durchzuführen, als einen API-Wrapper zu verwenden, da die Results eines Requests jedoch auch im Falle der Verwendung eines API-Wrappers erst auf die intern verwendeten Objekte gemappt werden müssen, ist der Mehraufwand vertretbar. Im Listing \ref{lst:nodeRestClient} ist der Aufruf der TrailerAddict-API anhand einer IMDb-ID zu sehen.

\medskip
\lstinputlisting[language=JavaScript,caption={Node-Rest-Client Beispiel},label={lst:nodeRestClient}]{Inhalt/Code/nodeRestClient.js}

\paragraph{Request}
Das Modul \textbf{Request} bewerkstelligt HTTP-Anfragen \citep{request} und dient in der Web-Applikation dem Erfassen des Quelltextes von \textbf{IMDb}, um die populärsten Filme eines spezifischen Jahres zu erfragen. Im Listing \ref{lst:request} ist zu sehen, wie der Quelltext der gegebenen IMDb-URL geladen wird.

\medskip
\lstinputlisting[language=JavaScript,caption={Request Beispiel},label={lst:request}]{Inhalt/Code/request.js}

\paragraph{cheerio}
Mithilfe des Node-Moduls \textbf{Cheerio} \citep{cheerio} lassen sich Informationen von Websites mittels CSS-Selektoren, wie sie in der Syntax von jQuery bekannt sind, erfassen. Die Verwendung dieser Bibliothek erleichtert das Web-Scraping \ua von \textbf{IMDb}. Im Listing \ref{lst:cheerio} ist zu sehen, wie die IMDb-IDs aus dem, durch das Scrapen erhaltenen Quelltext, erfasst werden. 

\medskip
\lstinputlisting[language=JavaScript,caption={Cheerio Beispiel},label={lst:cheerio}]{Inhalt/Code/cheerio.js}

\paragraph{async}
Das \textbf{async}-Modul \citep{async} erlaubt eine bessere Kontrolle über asynchron ausgeführte Funktionalität. Da \arbeitstitel \ an vielen Stellen mit mehreren APIs kommunizieren muss, ist die Asynchronität zwar generell ein Vorteil, jedoch werden auch Anfragen benötigt, die von mehreren asynchronen Requests abhängig sind. D.h., dass einige Requests von teilweise mehreren, vorangegangenen Requests abhängig sind. Mit async lassen sich Callbacks\footnote{Ein Callback ist eine ausführbare \glqq Funktion, die einer anderen Funktion als Parameter übergeben und von dieser unter gewissen Bedingungen wird.\grqq \citep[Vgl.][]{wikiCallback}} in vordefinierter Reihenfolge durchführen. Auch das Ausführen einer Serie von ein und dem selben Callback, um Werte einer Liste zu bearbeiten, ist möglich. Genauso lassen sich mehrere Requests gleichzeitig abarbeiten, bis dann der finale Callback ausgeführt werden kann, wenn alle Vorbedingungen erfüllt worden sind.

Im Listing \ref{lst:async} ist zu sehen, wie das \texttt{async}-Modul zur parallelen Ausführung von Funktionen beiträgt. Die Funktionen \texttt{get""Music""Suggestions""By""Searchterm} und \texttt{get""Movie""Suggestions""By""Searchterm} werden parallel ausgeführt. Sobald beide Funktionen abgeschlossen sind und die jeweiligen Callback-Funktionen ausgeführt werden, wird das in Zeile \ref{lst:asyncCallback} implementierte Callback ausgeführt. Über \texttt{results} kann auf die Ergebnisse der parallel ausgeführten Funktionen zugegriffen werden.

\medskip
\lstinputlisting[language=JavaScript,float,caption={Async Beispiel},label={lst:async}]{Inhalt/Code/async.js}

Außerdem wird die von \textbf{async} bereitgestellte Funktion \texttt{each} verwendet. Auf diesem Wege kann für jedes Item eines Result-Sets, das von einer API bezogen wurde, ein Request ausgeführt werden, um \zB Cover-Art nachzuladen. Diese Funktion wird zum Abfragen der Film-Trailer verwendet, indem anhand eines Sets von \textbf{IMDb}-IDs für jeden gefundenen Film ein Trailer gesucht wird. Dies ist \ua im Listing \ref{lst:interaction} in Zeile \ref{lst:asyncEach} zu sehen.


\medskip
\lstinputlisting[language=JavaScript,float,caption={Request, Cheerio und Async in Action},label={lst:interaction}]{Inhalt/Code/requestCheerioAsync.js}


% ====

% HERE

% ====

\subsection{Einbinden weiterer Medientypen und Dienste}
Die Architektur des Servers ist zur einfachen Einbindung zusätzlicher Medientypen und Datenquellen vorgesehen. Dafür ist zum einen zwischen dem Einbinden eines neuen Medientyps und einer neuen Datenquelle zu unterscheiden. Desweiteren ist es möglich eine Datenquelle lediglich für das Liefern von Suchvorschlägen, zum Liefern von Suchergebnissen oder beidem einzubinden. Dafür sind intern die Datenbank-Objekte \texttt{Suggestion} und \texttt{ResultItem} essentiell.

\paragraph{Einbinden eines Dienstes für Suchvorschläge}
Für das Einbinden einer weiteren Schnittstelle zum Liefern von Suchvorschlägen muss eine Funktion implementiert werden, die anhand des Parameters \texttt{String:searchTerm} eine Liste von \texttt{Suggestion}-Objekten (\texttt{List<Suggestion>:suggestions} zurück gibt. Werden die Ergebnisse der Suchvorschläge inklusive eines Icons oder Platzhalters für den implementierten Dienst und den Suchvorschlagdienst und die Quelle richtig angegeben, können die zusätzlichen Suchvorschläge ohne Darstellungsfehler in der Selectbox angezeigt werden. Mithilfe von \textbf{mongoose} kann das resultierende Ergebnis eines neuen Dienstes auf ein \texttt{Suggestion}-Objekt gemappt werden (siehe Listing \ref{lst:imdbToSuggestion}).

\medskip
\lstinputlisting[float,language=JavaScript,caption={Mappen eines IMDb-Results zu einem Suggestion-Objekt},label={lst:imdbToSuggestion}]{Inhalt/Code/imdbToSuggestion.js}

\paragraph{Einbinden eines Dienstes für Suchergebnisse}
Das Einbinden einer weiteren Schnittstelle für Suchergebnisse ist äquivalent zur Einbindung eine weiteren Dienstes für Suchvorschläge. In diesem Fall wird als Parameter der Zeitpunkt mitgegeben\footnote{Derzeit ist dies die jeweilige Jahreszahl mit vier Stellen, \zB \glqq 1985\grqq \ oder \glqq 2014\grqq .} und eine Liste an \texttt{ResultItem}-Objekten (\texttt{List<ResultItem>:resultItems}) zurück geliefert.

Die implementierte Funktion wird dann im \texttt{async}-Rumpf eingebunden werden. Dies ist am Beispiel der Film-Suchvorschläge mit den beiden Diensten \textbf{IMDb} und \textbf{Rotten Tomatoes} in Listing \ref{lst:movieSuggestions} zu sehen.

\medskip
\lstinputlisting[float,language=JavaScript,caption={Einbinden von zusätzlichen Diensten am Beispiel des Medientyps Film},label={lst:movieSuggestions}]{Inhalt/Code/getMovieSuggestionsBySearchterm.js}


\paragraph{Einbinden eines zusätzlichen Medientyps}
Der Ablauf der Anfragen externer Dienste ist hierarchisch aufgebaut. So sind jeweils die Anfragen für Musik-Inhalte und Video-Inhalte in parallel ablaufenden Funktionen gruppiert, d.h. dass die einzelnen Dienste nach Medientyp sortiert abgefragt werden (siehe Listing \ref{lst:getSuggestions}).\footnote{Der genaue Ablauf für das Liefern von Suchvorschlägen wird in der Grafik \ref{fig:suggestionsRequestDiagram} verdeutlicht, der Ablauf für das Liefern von Suchergebnissen wird in der Grafik \ref{fig:searchResultsRequestDiagram} dargestellt.} Das bedeutet, dass ein neuer Medientyp äquivalent eingebunden werden kann. Es muss eine Funktion implementiert werden, die die Abfragen der einzelnen Dienste, die den gleichen Medientyp liefern, bündelt. Das Ergebnis besteht aus einer Liste von \texttt{Suggestion}-Objekten. Diese Herangehensweise ist so gewählt worden, um das Feature der Eingrenzung nach Medientyp zu vereinfachen.

\medskip
\lstinputlisting[float,language=JavaScript,caption={Aufteilung der Requests an die externen Dienste nach Medientyp},label={lst:getSuggestions}]{Inhalt/Code/getSuggestions.js}